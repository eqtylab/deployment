# Auth0 with Google Cloud Storage Configuration
# Production deployment using Auth0 for identity and GCS for file storage
#
# Usage:
#   helm install governance-service ./charts/governance-service -f examples/values-auth0-gcs.yaml
#
# Prerequisites:
#   - GCS bucket created with appropriate IAM policies
#   - Auth0 tenant with application configured
#   - Cloud SQL PostgreSQL instance
#   - GKE cluster with Workload Identity configured (recommended)
#
# This example demonstrates:
#   - Auth0 as identity provider
#   - Google Cloud Storage for governance artifacts
#   - GKE with Workload Identity (recommended) or service account key
#   - AI features with Anthropic
#   - Production-ready configuration

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

config:
  appEnv: "production"
  logLevel: "info"

  server:
    readTimeout: 30
    writeTimeout: 30
    idleTimeout: 120

  # Storage configuration - Google Cloud Storage
  storageProvider: "gcs"
  gcsBucketName: "your-project-governance-artifacts"

  # Auth0 configuration
  auth0Domain: "your-tenant.auth0.com"

  # Integration URLs
  integrityServiceUrl: "http://governance-platform-integrity-service:3050"
  authServiceUrl: "http://governance-platform-auth-service:8080"

  # Service account for worker authentication
  serviceAccount:
    enabled: true
    serviceName: "governance-worker"

  # AI features
  ai:
    enabled: true
    provider: "anthropic"
    model: "claude-3-7-sonnet-latest"
    temperature: 0.7
    maxTokens: 4000
    timeoutSeconds: 60
    retryAttempts: 3
    useV2: true

auth0SyncAtStartup: true
auth0SyncPageSize: 100

# =============================================================================
# DATABASE CONFIGURATION (Cloud SQL)
# =============================================================================

externalDatabase:
  # Cloud SQL private IP or Cloud SQL Proxy connection
  host: "10.0.0.5" # Private IP, or use 127.0.0.1 with Cloud SQL Proxy sidecar
  port: 5432
  database: "governance"
  user: "governance_admin"
  sslmode: "require"

  passwordSecretKeyRef:
    name: "cloudsql-credentials"
    key: "password"

migrations:
  runAtStartup: true
  path: "/app/migrations"

# =============================================================================
# SECRET CONFIGURATION
# =============================================================================
#
# For GKE deployments, recommend using Workload Identity (no secrets needed for GCS)
# or Secret Manager with External Secrets Operator
#
# Option 1: Workload Identity (RECOMMENDED)
#   - Configure Workload Identity on GKE cluster
#   - Create GCP service account with GCS access
#   - Bind Kubernetes SA to GCP SA
#   - No GCS secrets needed in Kubernetes
#
# Option 2: Service Account Key (legacy)
#   Create secret with service account JSON:
#   kubectl create secret generic platform-gcs \
#     --from-file=service-account.json=/path/to/sa-key.json
#
# Example External Secret with Secret Manager:
#   apiVersion: external-secrets.io/v1beta1
#   kind: ExternalSecret
#   metadata:
#     name: governance-gcs-credentials
#   spec:
#     refreshInterval: 1h
#     secretStoreRef:
#       name: gcp-secret-manager
#       kind: ClusterSecretStore
#     target:
#       name: platform-gcs
#     data:
#       - secretKey: service-account.json
#         remoteRef:
#           key: governance-gcs-service-account

secrets:
  encryption:
    name: "platform-encryption"

  auth0:
    name: "platform-auth0"

  # GCS credentials - not needed if using Workload Identity
  storage:
    gcs:
      name: "platform-gcs"

  authService:
    name: "platform-auth-service"

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================

replicaCount: 3

image:
  repository: ghcr.io/eqtylab/governance-service
  pullPolicy: Always
  tag: ""

# Artifact Registry / GCR image pull
imagePullSecrets: []

# GKE Service Account with Workload Identity
serviceAccount:
  create: true
  automount: true
  annotations:
    # Workload Identity binding
    iam.gke.io/gcp-service-account: "governance-service@your-project.iam.gserviceaccount.com"
  name: ""

resources:
  requests:
    cpu: 250m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 1Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# =============================================================================
# INGRESS CONFIGURATION (GKE Ingress / Cloud Load Balancer)
# =============================================================================

ingress:
  enabled: true
  # Use GKE Ingress controller
  className: "gce"
  annotations:
    # Managed certificate
    networking.gke.io/managed-certificates: "governance-service-cert"
    # Static IP (optional)
    kubernetes.io/ingress.global-static-ip-name: "governance-service-ip"
    # HTTPS redirect
    networking.gke.io/v1beta1.FrontendConfig: "governance-service-frontend"
    # Cloud Armor (WAF)
    # networking.gke.io/v1beta1.BackendConfig: "governance-service-backend"
  hosts:
    - host: governance.your-domain.com
      paths:
        - path: "/governanceService/*"
          pathType: ImplementationSpecific
  tls: [] # TLS handled by managed certificate

# Alternatively, use nginx ingress:
# ingress:
#   enabled: true
#   className: "nginx"
#   annotations:
#     cert-manager.io/cluster-issuer: "letsencrypt-prod"
#     nginx.ingress.kubernetes.io/ssl-redirect: "true"
#     nginx.ingress.kubernetes.io/proxy-body-size: "64m"
#   hosts:
#     - host: governance.your-domain.com
#       paths:
#         - path: "/governanceService(/|$)(.*)"
#           pathType: ImplementationSpecific
#   tls:
#     - secretName: governance-service-tls
#       hosts:
#         - governance.your-domain.com

# =============================================================================
# HIGH AVAILABILITY
# =============================================================================

podDisruptionBudget:
  minAvailable: 2

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - governance-service
          topologyKey: "topology.kubernetes.io/zone"
  nodeAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
            - key: cloud.google.com/machine-family
              operator: In
              values:
                - e2
                - n2

# =============================================================================
# SECURITY
# =============================================================================

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

# =============================================================================
# PROBES
# =============================================================================

startupProbe:
  httpGet:
    path: /health
    port: http
  failureThreshold: 30
  periodSeconds: 10

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 15
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  failureThreshold: 2

# =============================================================================
# POD LABELS
# =============================================================================

podLabels:
  app.kubernetes.io/component: "backend-api"
