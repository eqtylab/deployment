# Auth0 with AWS S3 Storage Configuration
# Production deployment using Auth0 for identity and AWS S3 for file storage
#
# Usage:
#   helm install governance-service ./charts/governance-service -f examples/values-auth0-aws.yaml
#
# Prerequisites:
#   - AWS S3 bucket created with appropriate IAM policies
#   - Auth0 tenant with application configured
#   - Amazon RDS PostgreSQL instance
#   - AWS Secrets Manager or Kubernetes secrets
#   - EKS cluster with IRSA configured (recommended)
#
# This example demonstrates:
#   - Auth0 as identity provider
#   - AWS S3 for governance artifacts storage
#   - AWS EKS with IAM Roles for Service Accounts (IRSA)
#   - AI features with Anthropic
#   - Production-ready configuration

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

config:
  appEnv: "production"
  logLevel: "info"

  server:
    readTimeout: 30
    writeTimeout: 30
    idleTimeout: 120

  # Storage configuration - AWS S3
  storageProvider: "aws_s3"
  awsS3Region: "us-east-1"
  awsS3BucketName: "your-governance-artifacts-bucket"
  awsS3Folder: "artifacts" # Optional prefix/folder

  # Auth0 configuration
  auth0Domain: "your-tenant.auth0.com"

  # Integration URLs
  integrityServiceUrl: "http://governance-platform-integrity-service:3050"
  authServiceUrl: "http://governance-platform-auth-service:8080"

  # Indicator configuration
  indicators:
    configPath: "/app/configs/indicators"
    reloadInterval: 300
    osGuardrailsEnabled: false

  # Service account for worker authentication
  serviceAccount:
    enabled: true
    serviceName: "governance-worker"

  # AI features
  ai:
    enabled: true
    provider: "anthropic"
    model: "claude-3-7-sonnet-latest"
    temperature: 0.7
    maxTokens: 4000
    timeoutSeconds: 60
    retryAttempts: 3
    useV2: true

auth0SyncAtStartup: true
auth0SyncPageSize: 100

# =============================================================================
# DATABASE CONFIGURATION (AWS RDS)
# =============================================================================

externalDatabase:
  host: "governance-db.xxxxxxxxxxxx.us-east-1.rds.amazonaws.com"
  port: 5432
  database: "governance"
  user: "governance_admin"
  sslmode: "require"

  passwordSecretKeyRef:
    name: "rds-credentials"
    key: "password"

migrations:
  runAtStartup: true
  path: "/app/migrations"

# =============================================================================
# SECRET CONFIGURATION
# =============================================================================
#
# For AWS deployments, recommend using External Secrets Operator with AWS Secrets Manager
#
# Example ExternalSecret:
#   apiVersion: external-secrets.io/v1beta1
#   kind: ExternalSecret
#   metadata:
#     name: governance-s3-credentials
#   spec:
#     refreshInterval: 1h
#     secretStoreRef:
#       name: aws-secrets-manager
#       kind: ClusterSecretStore
#     target:
#       name: platform-aws-s3
#     data:
#       - secretKey: access-key-id
#         remoteRef:
#           key: governance/aws-s3
#           property: access_key_id
#       - secretKey: secret-access-key
#         remoteRef:
#           key: governance/aws-s3
#           property: secret_access_key
#
# Alternatively, use IRSA (IAM Roles for Service Accounts) - RECOMMENDED
# No secrets needed when using IRSA, just annotate the service account

secrets:
  encryption:
    name: "platform-encryption"
    key: "key"

  auth0:
    name: "platform-auth0"
    clientIdKey: "client-id"
    clientSecretKey: "client-secret"

  # S3 credentials - not needed if using IRSA
  storage:
    aws_s3:
      name: "platform-aws-s3"
      accessKeyIdKey: "access-key-id"
      secretAccessKeyKey: "secret-access-key"

  worker:
    name: "platform-governance-worker"
    encryptionKeyKey: "encryption-key"
    clientIdKey: "client-id"
    clientSecretKey: "client-secret"

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================

replicaCount: 3

image:
  repository: ghcr.io/eqtylab/governance-service
  pullPolicy: Always
  tag: ""

# ECR image pull (if using private ECR)
imagePullSecrets: []

# AWS EKS Service Account with IRSA
serviceAccount:
  create: true
  automount: true
  annotations:
    # IAM role for S3 access, RDS IAM auth, Secrets Manager
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/governance-service-role"
  name: ""

resources:
  requests:
    cpu: 250m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 1Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 15
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# =============================================================================
# INGRESS CONFIGURATION (AWS ALB)
# =============================================================================

ingress:
  enabled: true
  className: "alb"
  annotations:
    alb.ingress.kubernetes.io/scheme: "internet-facing"
    alb.ingress.kubernetes.io/target-type: "ip"
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    alb.ingress.kubernetes.io/ssl-redirect: "443"
    alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:us-east-1:123456789012:certificate/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    alb.ingress.kubernetes.io/healthcheck-path: "/health"
    alb.ingress.kubernetes.io/healthcheck-interval-seconds: "15"
    alb.ingress.kubernetes.io/success-codes: "200"
    # Enable WAF (optional)
    # alb.ingress.kubernetes.io/wafv2-acl-arn: "arn:aws:wafv2:..."
  hosts:
    - host: governance.your-domain.com
      paths:
        - path: "/governanceService"
          pathType: Prefix
  tls: [] # TLS handled by ALB with ACM certificate

# =============================================================================
# HIGH AVAILABILITY
# =============================================================================

podDisruptionBudget:
  minAvailable: 2

affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - governance-service
        topologyKey: "topology.kubernetes.io/zone"
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
        - matchExpressions:
            - key: node.kubernetes.io/instance-type
              operator: In
              values:
                - m5.large
                - m5.xlarge
                - m5.2xlarge

# =============================================================================
# SECURITY
# =============================================================================

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

# =============================================================================
# PROBES
# =============================================================================

startupProbe:
  httpGet:
    path: /health
    port: http
  failureThreshold: 30
  periodSeconds: 10

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 15
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  failureThreshold: 2
