# Production Hardened Configuration
# Maximum security configuration for production environments
#
# Usage:
#   helm install integrity-service ./charts/integrity-service -f examples/values-production-hardened.yaml
#
# This example demonstrates:
#   - Strict security contexts and pod security
#   - Resource limits and quotas
#   - High availability with anti-affinity
#   - Non-root execution
#   - Rate limiting and security headers
#   - Comprehensive health probes
#   - Network isolation ready

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================

replicaCount: 5

image:
  repository: ghcr.io/eqtylab/integrity-service
  pullPolicy: Always
  tag: "1.0.0" # Pin to specific version

imagePullSecrets:
  - name: "prod-registry-credentials"

serviceAccount:
  create: true
  automount: false # Disable auto-mount for security
  annotations:
    # AWS EKS IRSA
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/integrity-service-prod"
    # Or Azure Workload Identity
    # azure.workload.identity/client-id: "00000000-0000-0000-0000-000000000000"
  name: "integrity-service-prod"

# =============================================================================
# SECURITY CONTEXTS (HARDENED)
# =============================================================================

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  runAsGroup: 65534
  fsGroup: 65534
  fsGroupChangePolicy: "OnRootMismatch"
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  privileged: false
  capabilities:
    drop:
      - ALL
  # Note: Rust integrity service needs write access for temporary files
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 65534
  runAsGroup: 65534
  seccompProfile:
    type: RuntimeDefault

# =============================================================================
# RESOURCE CONFIGURATION (HARDENED)
# =============================================================================

resources:
  requests:
    cpu: 500m
    memory: 512Mi
    ephemeral-storage: "100Mi"
  limits:
    cpu: 2000m
    memory: 2Gi
    ephemeral-storage: "500Mi"

autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 70

# =============================================================================
# SERVICE CONFIGURATION
# =============================================================================

service:
  enabled: true
  type: ClusterIP
  port: 3050

# =============================================================================
# INGRESS CONFIGURATION (HARDENED)
# =============================================================================

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    # Strict security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-Frame-Options "DENY" always;
      add_header X-XSS-Protection "1; mode=block" always;
      add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    # Rate limiting
    nginx.ingress.kubernetes.io/limit-rps: "20"
    nginx.ingress.kubernetes.io/limit-connections: "10"
    nginx.ingress.kubernetes.io/limit-rpm: "200"
    # Body size and timeouts
    nginx.ingress.kubernetes.io/proxy-body-size: "32m"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "10"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "30"
  hosts:
    - host: governance.production-domain.com
      paths:
        - path: "/integrityService(/|$)(.*)"
          pathType: ImplementationSpecific
  tls:
    - secretName: integrity-service-prod-tls
      hosts:
        - governance.production-domain.com

# =============================================================================
# PERSISTENCE (DISABLED FOR STATELESS OPERATION)
# =============================================================================

persistence:
  enabled: false

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

config:
  rustEnv: "production"

  # Production database
  integrityAppDbHost: "prod-postgres.internal"
  integrityAppDbName: "IntegrityServiceDB"
  # Credentials from secrets

  # Storage configuration (choose one)
  integrityAppBlobStoreType: "aws_s3"
  integrityAppBlobStoreRegion: "us-east-1"
  integrityAppBlobStoreBucket: "prod-integrity-artifacts"
  integrityAppBlobStoreFolder: "integrity"

  # Minimal logging in production
  integrityAppLoggingLogLevelDefault: "warn"
  integrityAppLoggingLogLevelIntegrityService: "warn"

  # Auth service URL
  integrityAppAuthType: "auth_service"
  integrityAppAuthUrl: "http://governance-platform-auth-service:8080"

  # Public service URL
  integrityServiceUrl: "https://governance.production-domain.com/integrityService"

# =============================================================================
# SECRET CONFIGURATION
# =============================================================================

secrets:
  database:
    enabled: true
    name: "prod-database-credentials"

  storage:
    aws_s3:
      enabled: true
      name: "prod-aws-s3"

# =============================================================================
# HIGH AVAILABILITY (HARDENED)
# =============================================================================

podDisruptionBudget:
  minAvailable: 3

affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - integrity-service
        topologyKey: "kubernetes.io/hostname"
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - integrity-service
        topologyKey: "topology.kubernetes.io/zone"

nodeSelector:
  node-type: "production"

tolerations:
  - key: "production"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

# =============================================================================
# PROBES (CONSERVATIVE)
# =============================================================================

startupProbe:
  httpGet:
    path: /health/v1
    port: http
  failureThreshold: 60
  periodSeconds: 5

livenessProbe:
  httpGet:
    path: /health/v1
    port: http
  initialDelaySeconds: 60
  periodSeconds: 15
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health/v1
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# =============================================================================
# POD LABELS AND ANNOTATIONS
# =============================================================================

podLabels:
  security.kubernetes.io/audit: "true"
  environment: "production"

podAnnotations:
  seccomp.security.alpha.kubernetes.io/pod: runtime/default
  container.apparmor.security.beta.kubernetes.io/integrity-service: runtime/default
