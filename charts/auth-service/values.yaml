# Updated values for auth-service with all new configurations
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 2

image:
  repository: eqtylab/auth-service
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

service:
  type: ClusterIP
  port: 8080
  targetPort: http
  annotations: {}

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: auth.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: auth-tls
  #    hosts:
  #      - auth.local

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - auth-service
          topologyKey: kubernetes.io/hostname

# Auth Service Configuration
config:
  # Server configuration
  server:
    port: 8080
    host: "0.0.0.0"
    readTimeout: 30s
    writeTimeout: 30s
    idleTimeout: 120s
    environment: "production" # development, staging, production
    swaggerEnabled: false # Enable swagger in non-prod environments

  # Logging configuration
  logging:
    level: info # debug, info, warn, error
    format: json # json, text
    skipPaths: "/health,/health/live,/health/ready,/metrics"

  # Security configuration
  security:
    # API Secret for Auth0 Actions / IDP webhooks
    apiSecret: "" # Required - generate a strong secret
    # JWT Secret for session tokens (if needed)
    jwtSecret: "" # Optional - only if using local JWT generation
    # Use existing secret
    existingSecret: ""
    existingSecretKeys:
      apiSecret: "api-secret"
      jwtSecret: "jwt-secret"

  # Identity Provider Configuration
  idp:
    # Provider type: generic, keycloak, zitadel, auth0
    provider: "auth0"

    # Common OIDC settings (used by all providers)
    issuer: "" # e.g., https://your-tenant.auth0.com/
    clientId: ""
    clientSecret: ""
    redirectUri: "" # e.g., https://auth.yourdomain.com/callback
    scopes: "openid,profile,email"

    # Use existing secret for IDP credentials
    existingSecret: ""
    # Keys in the existing secret
    existingSecretKeys:
      clientId: "client-id"
      clientSecret: "client-secret"
      managementClientId: "mgmt-client-id"
      managementClientSecret: "mgmt-client-secret"

    # Provider-specific configurations

    # Generic OIDC provider settings
    generic:
      # Claim mappings
      userIdClaim: "sub"
      emailClaim: "email"
      nameClaim: "name"
      rolesClaim: "roles"
      groupsClaim: "groups"
      # Manual endpoint configuration (if auto-discovery fails)
      authorizationEndpoint: ""
      tokenEndpoint: ""
      userinfoEndpoint: ""
      jwksEndpoint: ""

    # Keycloak-specific settings
    keycloak:
      realm: "master"
      adminUrl: ""
      # Admin credentials (not recommended for production)
      adminUsername: ""
      adminPassword: ""
      # Service account (recommended)
      serviceAccountClientId: ""
      serviceAccountClientSecret: ""
      # Feature flags
      enableUserManagement: false
      enableGroupSync: false

    # Zitadel-specific settings
    zitadel:
      projectId: ""
      organizationId: ""
      apiEndpoint: ""
      # Service account key (mounted as volume)
      serviceKeyPath: "/secrets/zitadel-key.json"
      enableWebhooks: false

    # Auth0-specific settings
    auth0:
      domain: "" # e.g., your-tenant.auth0.com
      # Management API settings
      enableManagementAPI: true # Required for user/org management
      managementClientId: "" # M2M application client ID
      managementClientSecret: "" # M2M application client secret
      managementAudience: "" # e.g., https://your-tenant.auth0.com/api/v2/
      apiIdentifier: "" # Your API identifier in Auth0
      # User creation settings
      defaultConnection: "Username-Password-Authentication"
      defaultRoles: "user" # Comma-separated list
      sendInvitationEmail: true
      # Custom domain (optional)
      customDomain: ""
      # Sync settings
      syncAtStartup: false # Enable Auth0 organization sync at startup
      syncPageSize: 100 # Page size for Auth0 API calls

    # Advanced settings
    httpTimeout: "30s"
    skipIssuerVerification: false # DANGEROUS - only for development
    skipClientIdCheck: false # DANGEROUS - only for development
    insecureSkipVerify: false # DANGEROUS - only for development
    cacheTTL: 3600
    maxRetries: 3

  # Database configuration
  database:
    host: "auth-service-postgresql"
    port: 5432
    name: "authservice"
    user: "authservice"
    password: "" # Will be auto-generated if using subchart
    sslMode: "disable" # disable, require, verify-ca, verify-full
    # Connection pool settings
    maxOpenConns: 25
    maxIdleConns: 5
    connMaxLifetime: "5m"
    # Migration settings
    autoMigrate: true # Run migrations on startup
    migrationsPath: "internal/database/migrations"
    # Use existing secret for database credentials
    existingSecret: ""
    # Keys in the existing secret
    existingSecretKeys:
      password: "password"

  # Integration with other services
  integrations:
    # Integrity Service URL (for DID key fallback)
    integrityServiceUrl: "" # e.g., http://integrity-service:8080
    # Governance Service callback URL
    governanceServiceUrl: "" # e.g., http://governance-service:10001

  # Key Vault configuration (for DID keys)
  keyVault:
    provider: "azure" # azure, hashicorp, local
    # DID Key cache settings
    cacheTTLMinutes: 15
    azure:
      vaultUrl: "" # e.g., https://your-vault.vault.azure.net/
      tenantId: ""
      clientId: ""
      clientSecret: ""
      # Use existing secret for Azure credentials
      existingSecret: ""
      existingSecretKeys:
        clientId: "client-id"
        clientSecret: "client-secret"
        tenantId: "tenant-id"
    hashicorp:
      address: "" # e.g., http://vault:8200
      token: ""
      # Use existing secret for Vault token
      existingSecret: ""
      existingSecretKeys:
        token: "token"

  # RBAC configuration
  rbac:
    # Cache settings for permission checks
    cache:
      enabled: true
      ttl: 300s # 5 minutes
      maxSize: 1000 # Maximum number of cached entries

  # CORS configuration
  cors:
    enabled: false # Set to false by default for k8s (ingress handles CORS)
    origins: "*" # Comma-separated list of allowed origins or "*" for all

  # Session configuration
  session:
    secret: "" # Session encryption secret
    duration: "24h" # Session duration
    # Use existing secret for session secret
    existingSecret: ""
    existingSecretKeys:
      secret: "session-secret"

  # Service Account configuration
  serviceAccounts:
    # Auto-create default service accounts on startup
    autoCreate: true
    # Default governance-worker service account
    governanceWorker:
      enabled: true
      name: "governance-worker"
      description: "Automated governance service worker for processing indicator evaluations"
      # Platform-wide access (no organization binding)
      organizationId: "" # Empty for platform-wide access
      scopes:
        - "governance:declarations:create"
        - "integrity:statements:create"
      # Auth0 M2M Application credentials for governance-worker
      # These are required for the service account to authenticate
      auth0ClientId: "" # AUTH0_GOVERNANCE_WORKER_CLIENT_ID
      auth0ClientSecret: "" # AUTH0_GOVERNANCE_WORKER_CLIENT_SECRET
    # Encryption key for service account secrets
    encryptionKey: "" # Base64 encoded 32-byte key
    # Use existing secret for encryption key
    existingSecret: ""
    # kubectl create secret generic governance-worker-credentials --from-literal=key="" --from-literal=governance-worker-client-id="" --from-literal=governance-worker-client-secret="" -n <namespace>
    existingSecretKeys:
      encryptionKey: "encryption-key"
      governanceWorkerClientId: "governance-worker-client-id"
      governanceWorkerClientSecret: "governance-worker-client-secret"

  # Rate limiting
  rateLimit:
    enabled: false
    requestsPerMinute: 60

# PostgreSQL subchart configuration
postgresql:
  enabled: false
  auth:
    username: authservice
    password: authservice # Change in production!
    database: authservice
  primary:
    persistence:
      enabled: true
      size: 10Gi
      storageClass: "" # Use default storage class
  metrics:
    enabled: false
    serviceMonitor:
      enabled: false

# Redis subchart configuration (for caching/sessions)
redis:
  enabled: false # Enable if using Redis for caching
  auth:
    enabled: true
    password: "" # Will be auto-generated
  master:
    persistence:
      enabled: false # Enable for production
      size: 8Gi
  replica:
    replicaCount: 1
    persistence:
      enabled: false

# Health check configuration
healthCheck:
  liveness:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readiness:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1

# Metrics configuration
metrics:
  enabled: false
  port: 9090
  path: /metrics
  serviceMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s
    labels: {}
    # Add labels for Prometheus Operator to discover
    # release: prometheus

# Network policies
networkPolicy:
  enabled: false
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: governance-service
      ports:
        - protocol: TCP
          port: 8080
  egress:
    # Allow DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    # Allow PostgreSQL
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: postgresql
      ports:
        - protocol: TCP
          port: 5432
    # Allow external HTTPS (for IDP communication)
    - to: []
      ports:
        - protocol: TCP
          port: 443
    # Allow internal service communication
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: integrity-service
      ports:
        - protocol: TCP
          port: 8080

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # maxUnavailable: 1

# Extra environment variables
extraEnvVars: []
# - name: EXTRA_VAR
#   value: "extra-value"

# Extra environment variables from secrets or configmaps
extraEnvVarsSecret: ""
extraEnvVarsConfigMap: ""

# Extra containers to add to the pod
extraContainers: []

# Extra init containers to add to the pod
extraInitContainers: []
# Example: Run migrations as init container (when autoMigrate is false)
# - name: run-migrations
#   image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
#   command: ["/app/migrate"]
#   env:
#     - name: DATABASE_URL
#       value: "postgres://$(DB_USER):$(DB_PASSWORD)@$(DB_HOST):$(DB_PORT)/$(DB_NAME)?sslmode=$(DB_SSL_MODE)"
#     - name: DATABASE_MIGRATIONS_PATH
#       value: "{{ .Values.config.database.migrationsPath }}"
#   envFrom:
#     - secretRef:
#         name: "{{ include \"auth-service.fullname\" . }}-db"

# Extra manifests to deploy
extraManifests: []

# Migration Job configuration
migration:
  enabled: false # Enable to run migrations as a Helm hook job
  # Job configuration
  backoffLimit: 3
  activeDeadlineSeconds: 300
  ttlSecondsAfterFinished: 300
  # Resources for migration job
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

# Service-specific environment overrides
# These are useful for different environments (dev, staging, prod)
envOverrides: {}
  # Example overrides for staging:
  # ENVIRONMENT: "staging"
  # LOG_LEVEL: "debug"
  # SWAGGER_ENABLED: "true"
  # IDP_SKIP_ISSUER_VERIFICATION: "true"  # Only for non-prod!
