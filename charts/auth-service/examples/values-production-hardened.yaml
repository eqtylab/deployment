# Production Hardened Configuration
# Maximum security configuration for production environments
#
# Usage:
#   helm install auth-service ./charts/auth-service -f examples/values-production-hardened.yaml
#
# This example demonstrates:
#   - Strict security contexts and pod security
#   - Network policies with least-privilege access
#   - Resource limits and quotas
#   - High availability with anti-affinity
#   - Comprehensive monitoring and alerting
#   - Rate limiting and security headers
#   - Read-only file systems
#   - Non-root execution

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

config:
  server:
    environment: "production"
    swaggerEnabled: false
    readTimeout: "15s"
    writeTimeout: "15s"
    idleTimeout: "60s"

  logging:
    level: "warn" # Minimal logging in production
    format: "json"
    skipPaths: "/health,/health/live,/health/ready,/metrics"

  cors:
    enabled: false

  idp:
    provider: "auth0"
    issuer: "https://your-tenant.auth0.com/"
    skipIssuerVerification: false

    auth0:
      domain: "your-tenant.auth0.com"
      enableManagementAPI: true
      managementAudience: "https://your-tenant.auth0.com/api/v2/"
      apiIdentifier: "https://api.your-app.com"
      defaultConnection: "Username-Password-Authentication"
      defaultRoles: ["user"]
      sendInvitationEmail: true
      syncAtStartup: false
      syncPageSize: 50 # Smaller batches for stability

  keyVault:
    provider: "azure"
    cacheTTLMinutes: 30 # Longer cache for reduced API calls

    azure:
      vaultUrl: "https://prod-keyvault.vault.azure.net/"
      tenantId: "your-azure-tenant-id"

  integrations:
    governanceServiceUrl: "http://governance-platform-governance-service:10001"

  serviceAccounts:
    autoCreate: false # Manual creation in production
    governanceWorker:
      enabled: true
      name: "governance-worker"
      description: "Production governance worker"
      audience: "https://your-tenant.auth0.com/api/v2/"

  # Rate limiting enabled for production
  rateLimit:
    enabled: true
    requestsPerMinute: 60

  rbac:
    cache:
      enabled: true
      ttl: "600s" # Longer cache for production
      maxSize: 5000

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================

externalDatabase:
  host: "prod-postgres.internal"
  port: 5432
  name: "governance"
  user: "auth_service_prod"
  sslMode: "verify-full" # Full SSL verification
  maxOpenConns: 100
  maxIdleConns: 25
  connMaxLifetime: "30m"

  passwordSecretKeyRef:
    name: "prod-database-credentials"
    key: "password"

migrations:
  runAtStartup: false # Run migrations separately in production
  path: "/internal/database/migrations"

# =============================================================================
# SECRET CONFIGURATION
# =============================================================================

secrets:
  # Auth0 credentials
  auth:
    auth0:
      name: "prod-auth0-credentials"

  # Auth service credentials
  authService:
    name: "prod-auth-service-security"

  # Secret manager credentials
  secretManager:
    azure_key_vault:
      name: "prod-azure-keyvault"

  # Governance worker credentials
  governanceWorker:
    name: "prod-governance-worker"

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================

replicaCount: 5

image:
  repository: ghcr.io/eqtylab/auth-service
  pullPolicy: Always
  # Pin to specific version in production
  tag: "1.0.0"

imagePullSecrets:
  - name: "prod-registry-credentials"

serviceAccount:
  create: true
  automount: false # Disable auto-mount for security
  annotations:
    # Add any cloud-specific annotations (e.g., IRSA, Workload Identity)
    iam.gke.io/gcp-service-account: "auth-service@project.iam.gserviceaccount.com"
  name: "auth-service-prod"

# =============================================================================
# SECURITY CONTEXTS (HARDENED)
# =============================================================================

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534 # nobody user
  runAsGroup: 65534
  fsGroup: 65534
  fsGroupChangePolicy: "OnRootMismatch"
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  privileged: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 65534
  runAsGroup: 65534
  seccompProfile:
    type: RuntimeDefault

# =============================================================================
# RESOURCE CONFIGURATION (HARDENED)
# =============================================================================

resources:
  requests:
    cpu: 500m
    memory: 512Mi
    ephemeral-storage: "100Mi"
  limits:
    cpu: 2000m
    memory: 2Gi
    ephemeral-storage: "500Mi"

autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPUUtilizationPercentage: 60 # Conservative target
  targetMemoryUtilizationPercentage: 70
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 15
        - type: Pods
          value: 4
          periodSeconds: 15
      selectPolicy: Max

# =============================================================================
# INGRESS CONFIGURATION (HARDENED)
# =============================================================================

ingress:
  enabled: true
  className: "nginx"
  annotations:
    # TLS
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

    # Security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-Frame-Options "DENY" always;
      add_header X-XSS-Protection "1; mode=block" always;
      add_header Referrer-Policy "strict-origin-when-cross-origin" always;
      add_header Content-Security-Policy "default-src 'self'" always;

    # Rate limiting at ingress level
    nginx.ingress.kubernetes.io/limit-rps: "10"
    nginx.ingress.kubernetes.io/limit-connections: "5"

    # Proxy settings
    nginx.ingress.kubernetes.io/proxy-body-size: "1m"
    nginx.ingress.kubernetes.io/proxy-buffer-size: "8k"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "10"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "30"

  hosts:
    - host: auth.production-domain.com
      paths:
        - path: "/authService(/|$)(.*)"
          pathType: ImplementationSpecific
  tls:
    - secretName: auth-service-prod-tls
      hosts:
        - auth.production-domain.com

# =============================================================================
# OBSERVABILITY (COMPREHENSIVE)
# =============================================================================

metrics:
  enabled: true
  port: 9090
  path: "/metrics"
  serviceMonitor:
    enabled: true
    interval: "15s"
    scrapeTimeout: "10s"
    labels:
      release: prometheus
      environment: production

# =============================================================================
# HIGH AVAILABILITY (HARDENED)
# =============================================================================

podDisruptionBudget:
  enabled: true
  minAvailable: 3 # At least 3 pods always available

# Strict anti-affinity and zone spreading
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - auth-service
        topologyKey: "kubernetes.io/hostname"
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - auth-service
        topologyKey: "topology.kubernetes.io/zone"

nodeSelector:
  node-type: "production"

tolerations:
  - key: "production"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

# =============================================================================
# NETWORK POLICY (STRICT)
# =============================================================================

networkPolicy:
  enabled: true
  ingress:
    # Only allow ingress from nginx controller
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
          podSelector:
            matchLabels:
              app.kubernetes.io/name: ingress-nginx
      ports:
        - protocol: TCP
          port: 8080
    # Allow from governance-service only
    - from:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: governance-service
      ports:
        - protocol: TCP
          port: 8080
    # Allow Prometheus scraping
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
          podSelector:
            matchLabels:
              app.kubernetes.io/name: prometheus
      ports:
        - protocol: TCP
          port: 9090

  egress:
    # DNS only to kube-dns
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
          podSelector:
            matchLabels:
              k8s-app: kube-dns
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
    # PostgreSQL - specific pod
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: postgresql
      ports:
        - protocol: TCP
          port: 5432
    # Auth0 (external HTTPS)
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
            except:
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
      ports:
        - protocol: TCP
          port: 443
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: governance-service
      ports:
        - protocol: TCP
          port: 10001

# =============================================================================
# PROBES (CONSERVATIVE)
# =============================================================================

startupProbe:
  httpGet:
    path: /health
    port: http
  failureThreshold: 60
  periodSeconds: 5

livenessProbe:
  httpGet:
    path: /health/live
    port: http
  initialDelaySeconds: 60
  periodSeconds: 15
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  httpGet:
    path: /health/ready
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

# =============================================================================
# EXTRA SECURITY
# =============================================================================

# Add pod labels for network policy matching
podLabels:
  security.kubernetes.io/audit: "true"
  environment: "production"

# Annotations for security scanning
podAnnotations:
  seccomp.security.alpha.kubernetes.io/pod: runtime/default
  container.apparmor.security.beta.kubernetes.io/auth-service: runtime/default

# No extra manifests in hardened deployment
extraEnvVars: []
extraEnvVarsSecret: ""
extraEnvVarsConfigMap: ""
extraContainers: []
extraInitContainers: []
extraManifests: []
