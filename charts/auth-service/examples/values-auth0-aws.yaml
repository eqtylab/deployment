# Auth0 with AWS Infrastructure
# Configuration for deploying on AWS with EKS, RDS, and AWS Secrets Manager
#
# Usage:
#   helm install auth-service ./charts/auth-service -f examples/values-auth0-aws.yaml
#
# Prerequisites:
#   - AWS EKS cluster with IRSA (IAM Roles for Service Accounts) configured
#   - Amazon RDS PostgreSQL instance
#   - AWS Secrets Manager secrets created
#   - Auth0 tenant configured with application and API
#   - ALB Ingress Controller or NGINX Ingress installed
#
# This example demonstrates:
#   - Auth0 as identity provider
#   - AWS RDS PostgreSQL for database
#   - AWS Secrets Manager for secret management (via External Secrets or similar)
#   - AWS ALB Ingress annotations
#   - Production-ready HA configuration

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

config:
  server:
    environment: "production"
    swaggerEnabled: false

  logging:
    level: "info"
    format: "json"
    skipPaths: "/health,/health/live,/health/ready,/metrics"

  cors:
    enabled: false

  idp:
    provider: "auth0"
    issuer: "https://your-tenant.auth0.com/"
    skipIssuerVerification: false

    auth0:
      domain: "your-tenant.auth0.com"
      enableManagementAPI: true
      managementAudience: "https://your-tenant.auth0.com/api/v2/"
      apiIdentifier: "https://api.your-app.com"
      defaultConnection: "Username-Password-Authentication"
      defaultRoles: ["user"]
      sendInvitationEmail: true
      syncAtStartup: true
      syncPageSize: 100

  # AWS Secrets Manager for key vault (or use HashiCorp Vault on AWS)
  # Note: This requires a custom implementation or AWS KMS for DID signing
  keyVault:
    provider: "aws"
    cacheTTLMinutes: 15

  integrations:
    integrityServiceUrl: "http://governance-platform-integrity-service:3050"
    governanceServiceUrl: "http://governance-platform-governance-service:10001"

  serviceAccounts:
    autoCreate: true
    governanceWorker:
      enabled: true
      name: "governance-worker"
      description: "Automated governance service worker"
      scopes:
        - "governance:declarations:create"
        - "integrity:statements:create"
      audience: "https://your-tenant.auth0.com/api/v2/"

  rbac:
    cache:
      enabled: true
      ttl: "300s"
      maxSize: 1000

  rateLimit:
    enabled: true
    requestsPerMinute: 120

# =============================================================================
# DATABASE CONFIGURATION (AWS RDS)
# =============================================================================

externalDatabase:
  # AWS RDS PostgreSQL endpoint
  host: "governance-db.xxxxxxxxxxxx.us-east-1.rds.amazonaws.com"
  port: 5432
  name: "governance"
  user: "governance_admin"
  sslMode: "require"
  maxOpenConns: 50
  maxIdleConns: 10
  connMaxLifetime: "10m"

  # Reference to Kubernetes secret (created from AWS Secrets Manager)
  passwordSecretKeyRef:
    name: "rds-credentials"
    key: "password"

migrations:
  runAtStartup: true
  path: "/internal/database/migrations"

# =============================================================================
# SECRET CONFIGURATION
# =============================================================================
#
# These secrets should be synced from AWS Secrets Manager using:
#   - External Secrets Operator (recommended)
#   - AWS Secrets CSI Driver
#   - Manual secret creation from AWS CLI
#
# Example External Secret:
#   apiVersion: external-secrets.io/v1beta1
#   kind: ExternalSecret
#   metadata:
#     name: auth0-credentials
#   spec:
#     refreshInterval: 1h
#     secretStoreRef:
#       name: aws-secrets-manager
#       kind: ClusterSecretStore
#     target:
#       name: platform-auth0
#     data:
#       - secretKey: client-id
#         remoteRef:
#           key: governance/auth0
#           property: client_id

secrets:
  auth:
    name: "platform-auth0"
    keys:
      clientId: "client-id"
      clientSecret: "client-secret"
      managementClientId: "mgmt-client-id"
      managementClientSecret: "mgmt-client-secret"

  security:
    name: "platform-auth-service"
    keys:
      apiSecret: "api-secret"
      jwtSecret: "jwt-secret"

  session:
    name: "platform-auth-service"
    keys:
      secret: "session-secret"

  worker:
    name: "platform-governance-worker"
    keys:
      encryptionKey: "encryption-key"
      clientId: "client-id"
      clientSecret: "client-secret"

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================

replicaCount: 3

image:
  repository: ghcr.io/eqtylab/auth-service
  pullPolicy: Always
  tag: ""

# ECR image pull (if using private ECR)
imagePullSecrets: []
  # - name: "ecr-registry"

# AWS EKS Service Account with IRSA
serviceAccount:
  create: true
  automount: true
  annotations:
    # IAM role for accessing AWS Secrets Manager, RDS IAM auth, etc.
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/governance-auth-service"
  name: ""

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 15
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

resources:
  requests:
    cpu: 250m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 1Gi

# =============================================================================
# INGRESS CONFIGURATION (AWS ALB)
# =============================================================================

ingress:
  enabled: true
  # Use AWS ALB Ingress Controller
  className: "alb"
  annotations:
    # ALB Ingress Controller annotations
    alb.ingress.kubernetes.io/scheme: "internet-facing"
    alb.ingress.kubernetes.io/target-type: "ip"
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    alb.ingress.kubernetes.io/ssl-redirect: "443"
    alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:us-east-1:123456789012:certificate/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    alb.ingress.kubernetes.io/healthcheck-path: "/health"
    alb.ingress.kubernetes.io/healthcheck-interval-seconds: "15"
    alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
    alb.ingress.kubernetes.io/healthy-threshold-count: "2"
    alb.ingress.kubernetes.io/unhealthy-threshold-count: "3"
    # Security group for ALB
    alb.ingress.kubernetes.io/security-groups: "sg-xxxxxxxxxxxxxxxxx"
    # WAF integration (optional)
    # alb.ingress.kubernetes.io/wafv2-acl-arn: "arn:aws:wafv2:..."
  hosts:
    - host: auth.your-domain.com
      paths:
        - path: "/authService(/|$)(.*)"
          pathType: ImplementationSpecific
  tls: [] # TLS handled by ALB with ACM certificate

# =============================================================================
# OBSERVABILITY
# =============================================================================

metrics:
  enabled: true
  port: 9090
  path: "/metrics"
  serviceMonitor:
    enabled: true
    interval: "30s"
    scrapeTimeout: "10s"
    labels:
      # Match Prometheus Operator selector
      release: prometheus

# =============================================================================
# HIGH AVAILABILITY
# =============================================================================

podDisruptionBudget:
  enabled: true
  minAvailable: 2

affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - auth-service
        topologyKey: "topology.kubernetes.io/zone"
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
        - matchExpressions:
            - key: node.kubernetes.io/instance-type
              operator: In
              values:
                - m5.large
                - m5.xlarge
                - m5.2xlarge

# Spread across availability zones
topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: auth-service

# =============================================================================
# NETWORK POLICY
# =============================================================================

networkPolicy:
  enabled: true
  ingress:
    - from:
        # Allow from ALB (all VPC traffic)
        - ipBlock:
            cidr: 10.0.0.0/8
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: governance-service
      ports:
        - protocol: TCP
          port: 8080
  egress:
    # Allow DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    # Allow RDS
    - to: []
      ports:
        - protocol: TCP
          port: 5432
    # Allow external HTTPS (Auth0, AWS services)
    - to: []
      ports:
        - protocol: TCP
          port: 443
    # Allow internal services
    - to:
        - podSelector: {}
      ports:
        - protocol: TCP
          port: 3050
        - protocol: TCP
          port: 10001

# =============================================================================
# PROBES
# =============================================================================

startupProbe:
  httpGet:
    path: /health
    port: http
  failureThreshold: 30
  periodSeconds: 10

livenessProbe:
  httpGet:
    path: /health/live
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health/ready
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
