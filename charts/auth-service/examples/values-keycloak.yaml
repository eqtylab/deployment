# Keycloak Provider Configuration for Enterprise/On-Premises Deployment
# This values file configures the auth-service to use Keycloak as the identity provider
#
# Usage:
#   helm install auth-service ./charts/auth-service -f examples/values-keycloak.yaml

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

config:
  # Server configuration
  server:
    environment: "production"
    swaggerEnabled: false

  # Logging configuration
  logging:
    level: "info"
    format: "json"

  # CORS configuration (may be needed for on-premises)
  cors:
    enabled: true
    origins: "https://app.your-domain.com,https://app-staging.your-domain.com"

  # Identity Provider configuration
  idp:
    provider: "keycloak"
    issuer: "https://keycloak.your-domain.com/realms/governance"

    # Keycloak-specific configuration
    keycloak:
      realm: "governance"
      adminUrl: "https://keycloak.your-domain.com"
      enableUserManagement: true
      enableGroupSync: false

  # Key Vault configuration for DID key signing (HashiCorp Vault for on-premises)
  keyVault:
    provider: "hashicorp"
    cacheTTLMinutes: 15
    hashicorp:
      address: "https://vault.your-domain.local:8200"

  # Service integration URLs
  integrations:
    governanceServiceUrl: "http://governance-platform-governance-service:10001"

  # Service account configuration
  serviceAccounts:
    autoCreate: true
    governanceWorker:
      enabled: true
      name: "governance-worker"
      description: "Automated governance service worker for processing indicator evaluations"

  # Token exchange configuration (for Keycloak integration)
  tokenExchange:
    enabled: true
    keyId: "auth-service-prod-001"

  # RBAC cache configuration
  rbac:
    cache:
      enabled: true
      ttl: "300s"
      maxSize: 1000

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================

externalDatabase:
  host: "postgresql.your-domain.local"
  port: 5432
  name: "governance"
  user: "postgres"
  sslMode: "require"
  maxOpenConns: 25
  maxIdleConns: 5
  connMaxLifetime: "5m"

  # Use existing secret for credentials
  passwordSecretKeyRef:
    name: "platform-database"
    key: "password"

migrations:
  runAtStartup: true
  path: "/internal/database/migrations"

# =============================================================================
# SECRET CONFIGURATION
# =============================================================================

secrets:
  # Keycloak credentials
  auth:
    keycloak:
      name: "platform-keycloak"

  # Auth service credentials
  authService:
    name: "platform-auth-service"

  # Secret manager credentials
  secretManager:
    azure_key_vault:
      name: "platform-azure-key-vault"

  # Governance worker credentials
  governanceWorker:
    name: "platform-governance-worker"

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================

# Conservative settings for on-premises deployment
replicaCount: 2

image:
  repository: ghcr.io/eqtylab/auth-service
  pullPolicy: IfNotPresent
  tag: "" # Uses appVersion from Chart.yaml

imagePullSecrets:
  - name: "platform-image-pull-secret"

autoscaling:
  enabled: false # Manual scaling for on-premises

resources:
  requests:
    cpu: 200m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 1Gi

# =============================================================================
# OBSERVABILITY
# =============================================================================

metrics:
  enabled: true
  port: 9090
  path: "/metrics"
  serviceMonitor:
    enabled: true
    interval: "30s"
    labels:
      release: prometheus

# =============================================================================
# INGRESS CONFIGURATION
# =============================================================================

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "internal-ca"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-buffer-size: "16k"
  hosts:
    - host: auth.your-domain.local
      paths:
        - path: "/authService(/|$)(.*)"
          pathType: ImplementationSpecific
  tls:
    - secretName: auth-service-tls
      hosts:
        - auth.your-domain.local

# =============================================================================
# HIGH AVAILABILITY
# =============================================================================

podDisruptionBudget:
  enabled: true
  minAvailable: 1

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - auth-service
          topologyKey: kubernetes.io/hostname

# =============================================================================
# NETWORK POLICY
# =============================================================================

networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: governance-service
      ports:
        - protocol: TCP
          port: 8080
  egress:
    # Allow DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    # Allow PostgreSQL
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: postgresql
      ports:
        - protocol: TCP
          port: 5432
    # Allow Keycloak
    - to: []
      ports:
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 8080
    # Allow Vault
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: vault
      ports:
        - protocol: TCP
          port: 8200

# =============================================================================
# NODE PLACEMENT
# =============================================================================

nodeSelector:
  node-role.kubernetes.io/worker: "true"

tolerations: []
